-------------------------------------------------------------------------------------------------------------------
                                               INSTRUCTION
-------------------------------------------------------------------------------------------------------------------
                    Node Dependencies
-------------------------------------------------------------------------------------------------------------------
   - client/package.json
    1. add general mamifest of datta setting this file
    - {
    -   "name": "restaurants",
    -   "version": "",
    -   "description": "",
    -   "engines": {
    -     "node": "0.12.2"
    -   },
    -   "author": "Alex Purkhalo",
    -   "license": "",
    -   "dependencies": { },
    -   "devDependencies": { },
    -   "scripts": { }
    - }

     2. use command for npm installing and check that its give no errors
     $ npm install

     3. add dependencies of npm packajes
     - "dependencies": {
     -    "babel": "*",
     -    "babel-core": "^5.4.5",
     -    "babel-loader": "^5.1.3",
     -    "babel-runtime": "^5.1.3",
     -    "body-parser": "^1.12.4",
     -    "es5-shim": "^4.1.3",
     -    "imports-loader": "^0.6.3",
     -    "loader-utils": "*",
     -    "lodash": "*",
     -    "react": "^0.13.3",
     -    "flux": "2.0.3",
     -    "axios": "*",
     -    "express": "^4.12.4",
     -    "webpack": "^1.9.7"
     - }

     3. try to install packages again
     $ npm install

    - client/assets/javascripts/App.js
     1. run the webpack
     $ webpack -w --config webpack.rails.config.js

     2. add array mapping with lodash
     - import _ from 'lodash'
     -
     _ _.map([1,2,3]), (i) => { return i*i; })

    - client/webpack.rails.config.js
     # add configuration of module loaders and check compilation after then
     - config.module.loaders.push(
     -   {test: /\.jsx$/, exclude: /node_modules/, loader: 'babel-loader'},
     -   {test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader'}
     - );



-------------------------------------------------------------------------------------------------------------------
                               Webpack Setting Up
-------------------------------------------------------------------------------------------------------------------
    - client/ (soft installing)
     # create client folder in your application
     # install webpack with npm tha require installed nodejs
     $ sudo apt-get install nodejs
     $ npm
     $ sudo npm install -g webpack

    - client/webpack.rails.config.js
     # create rails config file with requirements of config file
     - const config = require('./webpack.common.config')

    - client/1webpack.common.config.js
     1. create commin config file and add path requirement
     - const path = require('path')

     3. add module exports with its configuration
     - module.exports = {
     -   context: __dirname,
     -   entry: ['./assets/javascripts/App'],
     -   resolve: {
     -     root: [path.join(__dirname, 'scripts'),
     -            path.join(__dirname, 'assets/javascripts')],
     -     extensions: ['', '.webpack.js', '.web.js', '.js', '.jsx', '.config.js']
     -   },
     -   module: {
     -     loaders: []
     -   }
     - }

    - client/webpack.rails.common.js
     1. add config output with its settings
     - config.output = {
     -   filename: 'client-bundle.js',
     -   path: '../app/assets/javascripts/generated'
     - };

     2. add module exports of config instance
     - module.exports = config

     3. checking: console
     - locate to client folder throw console
     - $ webpack
     - make sure that as output u get using instruction
     - $ webpack -w --config webpack.rails.config.js
     - as output u should get error that says that webpack can't find assets/javascripts/App file

    - client/assets/javascripts/App.js
     # create this file and add some comment there


    - app/assets/javascripts/generated/client-bundle.js
    # you should see compiled data
    # notice: pay attention file located not fron 'clien' folder
    # also u can try changed data from App.js file in client folder and look have changes info in compiled file

-------------------------------------------------------------------------------------------------------------------
                               RealTime
-------------------------------------------------------------------------------------------------------------------
    - app/controllers/comments_controller.rb
      1. create index action of comment's controller
      - def index
      -   @comments = Comment.where(restaurant_id: params[:restaurant_id])
      - end

      2. localhost:300/restaurants/1/comments.json
      - json data tha represents as array that contains objects with comments information

    - app/assets/javascripts/actions.es6
      1. add 'watch' function with get method comments setting
      - watch() {
      -   Api.get(`/restaurants/${this.restaurantId}/comments`).then( comments => {
      -     this.setComments(comments);
      -   });
      - }

      2. create 'watchInterval' instance in constructor that comes equal to setting of interval of 'watch' function
      - constructor(restaurantId) {
      -   this.restaurantId = restaurantId
      -   this.watchInterval = setInterval(this.watch.bind(this), 1000);
      - }

-------------------------------------------------------------------------------------------------------------------
                                Rank for Comments
-------------------------------------------------------------------------------------------------------------------
    - config/routes.rb
      # add 'put' method for 'comments#upvote'
      - ...
      - resources :comments do
      -  put 'upvote', to: 'comments#upvote'
      - end
      - ...

    - app/controllers/comments_controllers.rb
      # add upvote method with upvoting for certain comment
      - def upvote
      -   Comment.upvote(params[:comment_id]
      -   @comment = Comment.find(params[:comment_id])
      - end

    - app/models/comment.rb
      # add static 'upvote' function with updating of 'rank' attribute
      - def self.upvote(id)
      -   comment = find(id)
      -   comment.update_attributes(rank: comment.rank.to_i + 1)
      - end

    - app/assets/javascripts/constants.es6
      # add 'comments.upvote' for constant
      - UPVOTE_COMMENT: 'comments.upvote'

    - app/assets/javascripts/actions.es6
      # add static 'upvoteComment' function for info putting
      - static upvoteComment(comment) {
      -     Api.put(`/restaurants/1/comments/${comment.id}/upvote`).then( resp => {
      -         return resp.json()
      -     }).then( comment => {
      -         AppDispatcher.dispatch({
      -             actionType: Constants.UPVOTE_COMMENT,
      -             comment: comment
      -         });
      -     });
      - }

    - app/assets/javascripts/stores/comment_store.es6
      # add case for comment upvoting in switch of AppDispatcher's register method that will show 'payload' to console
      - ...
      - case Constants.UPVOTE_COMMENT:
      -   console.log(payload)
      -   break;
      - ...

    - app/assets/javascripts/components/comment.es6
      1. add button for comment upvoting in rendering of component
      - <button onClick={this.onUpvote.bind(this)}>+1</button>

      2. add its function
      - onUpvote(event) { this.context.actions.upvoteComment(this.props) }

      3. add context to make actions available for Comment component
      - static get contextTypes() { return { actions: React.PropTypes.func.isRequired }}

      4. checking: browser
      - click on '+1' button and you will get error: 'Api.put is not a function'

    - app/assets/javascripts/api.es6
      1. add static 'put' function with put method
      - static put(route, params) {
      -   return fetch(route + '.json', {
      -     method: 'put',
      -     credentials: 'include',
      -     headers: this.headers()
      -   })
      - }

      2. checking: browser
      - now try to put vote and you will get 500 error with missing template

    - app/controllers/comments_controller.rb

      1. add render of 'create' to 'upvote' method
      - ...
      -   render :create
      - end

      2. checkign: browser
      - now after putting you should get object with its 'actionType' and 'comment' object
      - in preview you should get its keys as: 'author', 'body', ... and at last 'rank' key
      - putt rank again and your rank should increase

    - app/assets/javascripts/components/comment.es6
      # add showing of current comment's rank to render method
      - render() { return { ... {this.props.rank } }

    - app/assets/javascripts/stores/comment_store
      1. add to switch of  AppDispatcher's register payloading with emit changing
      - ...
      - case Constants.UPVOTE_COMMENT:
      -   this.upvote(payload.comment);
      -   this.emitChange();
      -   break;
      - ...

      2. add 'upvote' function that increase comment's rank
      - upvote (comment) {
      -     this._comments[comment.id].rank++;
      - }

-------------------------------------------------------------------------------------------------------------------
                                  Incorporating BiDirectional Data Flow
-------------------------------------------------------------------------------------------------------------------
                                   Components Styling
-------------------------------------------------------------------------------------------------------------------
    - comment.es6
      1. create 'onCommentSubmitted' function taht takes 'event' as parameter
         its change state of 'isReplying' to false
       - onCommentSubmitted(event) { this.setState({isReplying: false}) }

      2. add 'onCommentSubmitted' property to rendering of 'CommentForm' that equal to its function
       - <CommentForm onCommentSubmitted={this.onCommentSubmitted.bind(this) />

    - comment_form.es6
      1. add global 'get' 'PropTypes' function that returns React properties
         of 'isReplying' boolean, 'onCommentSubmitted' function and 'parent_id' number
       - static get PropTypes() {
       -    return {
       -        isReplying: React.PropTypes.bool,
       -        onCommentSubmitted: React.PropTypes.func,
       -        parent_id: React.PropTypes.number
       -    }
       - }

      2. add if statement of 'onCommentSubmitted' function that use its functuin for 'submitComment' function that
       - if (this.props.onCommentSubmitted) { this.props.onCommentSubmitted() }

      3. checking: browser
       - add comment for child form, form shoud disappear after adding a comment

-------------------------------------------------------------------------------------------------------------------
    - comment_list.es6
        # go to rendering of component and convert it to 'ul' tag instead of a 'div'
        - return <ul> ... </ul>

    - comment.es6
        # go to rendering of component and convert it ti 'li' tag
        - return <li> ... </li>

    - comment_form.es6
      1. wrap form rendering to 'div' tag
       - <div><form> ... </form></div>

      2. add class with expression of state named 'isReplying' if its true show empty class '' else 'hide' class
       - <form className={ this.state.isReplying ? '' : 'hide'> ... </form>

      3. checking: browser
       - all forms should disappear

      4. add 'this.state.isReplying' that equal to 'props.isReplying' or 'false' to constructor
       - constructor(props) { this.state.isReplying = props.isReplying || false}

    - comment_section.es6
      1. add 'isReplying' property that equal to true for rendering of 'CommentForm' component
       - <CommentForm isReplying={true} />

      2. checking: browser
       - main form should be visible

    - comment.es6
      1. define 'replyText' constant in render method that equal to 'this.state.isReplying'
         that take 'Hide' text if its true else 'Reply'
       - const replyText = this.state.isReplying ? 'Hide' : 'True';

      2. define 'this.state' for 'isReplying' that is 'false' by default, do this in constructor that you need to create
       - constructor() {
       -    super()
       -    this.state = { isReplying: false }
       - }

      3. add button with 'onClick' property that equal to expression of 'this.onToggleReply' functin
         as text it should take expression of 'replyText' constant
       - <button onClick={this.onToggleReply.bind(this)>{replyText}</button>

      4. add 'onToggleReply' function that change state of 'isReplying'
       - onToggleReply() { this.setState({isReplying: !this.state.isReplying}) }

      5. checking: browser
       - click on 'Reply' button and this should change to 'Hide'
       - do the same with 'Hide' button this should be changed to 'Reply' after clicking

      6. add 'isReplying' property that equal to 'this.state.isReplying' to rendering of 'CommentForm' component
       - <CommentForm isReplying={this.state.isReplying}

    - comment_form.es6
      1. in class name of 'form' tag in component rendering change 'state' of 'isReplying' to 'props'
       - <form className={ this.props.isReplying? '' : 'hide'></form>

      2. checking: browser
       - click on 'Reply' button and you should get form
       - click on 'Hide' and forms shoud disappear

-------------------------------------------------------------------------------------------------------------------
                                   Component Tree
-------------------------------------------------------------------------------------------------------------------
    - app/controllers/comments_controller.rb
        # add 'parent_id' property to 'comment_params' method
        - def comment_params
        -   params.require(:comment).permit(..., :parent_id)
        - end

     - app/views/comments/_comment.json.jbuilder
      1. add a 'parent_id' property to other
        - json.(comment, :id, :body, :author, :rank, :parent_id)

      2. checking: browser
        - go to source of page (Ctrl + U)
        - Try ot find 'parent_id' under 'CommentSection' component (should almost one nested comment)
        - back to browser and add new comment from form in 'CommentLost'
        - check the just sended request and check its 'Preview'
        - in 'Preview' u should see all poperties, like: 'author, body, id, rank, parent_id'
        - come to admin panel and find added throw commets list's form
        - this comment should has certain number in 'ancestry' field

    - app/assets/javascript/stores/comment_store.es6
      1. checking: browser
        - look at data structure in 'CommentList' section
        - elements don't have visual nesting each between other

      2. go to 'comments' function and add 'parentId' parameter there
        - comments (parentId) { ... }

      3. add filter to 'this._comments' of 'comments' function
        - return this._comments.filter( c => { return c && c.parent_id === parentId });

    - app/assets/javascripts/components/comment_section.es6
        # add 'parent_id' that equal to 'null' for 'CommentList' component in 'render' function
        - <CommentList parent_id={null} />

    - app/assets/javascripts/components/comment_list.es6
        # add 'this.props.parent_id' as argument to 'comments' method in 'render' function
        - this.context.store.comments(this.props.parent_id).map(...)

    - app/assets/javascripts/components/comment.es6
      1. add 'CommentList' component with 'parent_id' atribute to 'render' method of 'Comment' class
        - <CommentList parent_id={this.props.id} />

      2. add import of 'CommentList' component
        - import CommentList from './comment_list'

      3. checking: browser
        - add new comment and check it in tree of comments with React tool
        - add to throw added comment's form a new comment
        - check its new comment in tree of components
        - this comment should locate in its parent comment component

-------------------------------------------------------------------------------------------------------------------
                                    Nesting Components
-------------------------------------------------------------------------------------------------------------------
    - components/comment.es6
      1. add 'Form' import to comment file
        - import 'CommentForm' from './comment_form';

      2. add 'id' key for 'propTypes' function
        - static get propTypes() { return { id: React.PropTypes.number, ..., ..., ... } }

      3. add rendering of 'CommentForm' after comment's body
       - ...
       - <p>{this.props.body}</p>
       - <CommentForm parent_id={this.props.id}/>
       - ...

      3. checking: browser
       - inspect one of the form
       - switch to React dev tool
       - check first 'CommentForm' that located before 'CommentList', this should has no properties
       - add new comment to list and check its properties, its should has certain 'parent_id'

    - components/comment_form.es6
       1. add console.log in 'submitComment' function
        - submitoCmment(event) { console.log(this.props); ... }

       2. in browser
        - add comment throw main 'CommentForm' (that comes first)
        - check in console that data has come as empty object
        - add comment throw one of 'CommentForm' from 'CommentList'
        - check that after submiting you have object with 'parent_id' in console

       3. add mering for argument in 'addComment' method from 'submitComment' function
        - ... this.context.actions.addComment(_.merge(this.state, { parent_id: this.props.parent_id })

       4. checking: browser, console
        - add new comment throw 'CommentList' form
        - open console with started server
        - find there 'Parameters' that equal to object with keys
        - on of these keys should be 'parent_id' that equal to certain id number

-------------------------------------------------------------------------------------------------------------------
                                        Working with Promises
-------------------------------------------------------------------------------------------------------------------
    - actions.es6
       1. go to 'addComment' function and find Api.post(...) method
          then add 'then' method with 'resp => {}' argument'
        - Api.post(...).then(resp => {})

       2. add console.log with 'resp' argument in body of fnction with 'resp' parameter
        - ... resp => { console.log(resp) } ...

    - checking: browser
       1. add comment and check console looking by 'Response'

       2. look in 'Response' there u should see: 'type', 'status', 'body' ...

    - actions.es6
       1. in body of 'resp' function add 'return' wit 'resp.json()'
        - ... resp => { return resp.json() }

       2. add another 'then' method with 'comment' function inside
        - Api.post(...).then(...).then( comment => {} )

       3. add console.log of 'comment' in function with 'comment' parameter
        - Api.post(...).then(...).then( comment => { console.log(comment) } )

    - checking: browser
       1. add some comment

       2. in console  you should get array with commen's data including its 'id'

    - actions.es6
       1. locate AppDispatcher with its method instead of console.log(comment) in second 'then' method
        - ...then( comment => { AppDispatcher.dispatch({ actionsType: ..., comment: ... }) } )

       2. instead taking a 'params' as value of 'comment' key add there 'comment' parameter
        - ...{ actionsType: ..., comment: comment }...


-------------------------------------------------------------------------------------------------------------------
                                        Sending Server Data
-------------------------------------------------------------------------------------------------------------------
    - api.es6
        1. create api.es6 file in app/assets/javascripts folder

        2. create Api class with its export:
            - class Api {}
            - export default Api

        3. add global 'post' with 'route' and 'params' parameters
            - static post(route, params) {}

        5. in 'post' method
            - return fetch(`${route}.json`, {}, { body: JSON.stringify(params) })

    - actions.es6
        1. class's import
            - 'import Api from "/api";

        2. in 'addComments' function:
           - 'Api.post('/restaurants/1/comments', { comment: params});'

    - checking: browser:
        1. comment_section shoud be rendered as before
        2. type something to form and send data
        3. in console you should get 404 error after sending of this data

    - api.es6
        1. in '{}' of 'fetch' method in 'post' function
            - {
            -     method: 'post',
            -     credentials: 'include',
            -     headers: this.headers()
            - }

        2. add another global 'headers' function into 'Api' class
           - static headers() {}

        3. in 'return' of 'headers' function
            - return {
            -    'Accept': 'application/json',
            -    'Content-Type': 'application/json',
            -    'X-CRF-Token': this.token(),
            -    'X-Requested-With': 'XMLHttpRequest'
            - }

        4. add global 'token' function to class
            - static token() {}

        5. in 'token' function add 'el' variable that equal to:
            - let el = document.querySelector('meta[name="crf-token"]')
            - return el ? el.getAttribute('conntent') : '';

    - checking: browser, console
        1. type in somethign to comment's form's fields and submit it
        2. in console ensure that now you get 404 of 'POST' method after data sending
        3. look to this request clother, and check the 'headers' of this
        4. we should get 'content-type', 'accept', 'Host', 'x-crf-token' and 'x-requested-with' keys with data
        5. in console with started server you should se 'Cannot render console with content type ...'

    - config/routes.rb
        1. add comments resource to restaurant resources
         - resources :restaurants do
         -     resources :comments
         - end
    - checking: browser
        1. type in something to comment's form and click on submit
        2. in console find 404 'POST' error and open its
        3. in 'Preview' section u gonna have following error: "uninitialized constant CommentsController"

    - app/controllers/comments_controller.rb
        1. generate new 'comment' controller
         - $ rails g controller comments

        2. add 'create' action to created controller
         - ...
         -    def create
         -    end
         - ...

    - checking: browser, console
        1. type in something to comment's form and click on submit
        2. in console with started server try to find 'Parameters: {"restaurant_id"=>"1", "comment"=>{}"}

    - api.es6
        1. add '_.merge()' to object that contain: 'method, headers, ...'
           and object that contains 'body' key with its value
           in 'fetch' method of 'post' function\
         - (..., _.merge({ method: 'post', ... }), { body: ... }));

    - checking: browser, console
        1. after data sending you should have 'Request Payload' in 'Headers' of 'POST' request
        2. 'Request Payload' should contains 'comment' object with its data
        3. in console instead of empty object of 'comment' key you must see its data

    - app/controllers/comments_controller.rb
        1. add instance of comment in 'create' action that equal 'comment_params' of 'Comment' table
         - @comment = Comment.create(comment_params)

        2. define 'comment_params' method
         - def comment_params
         - end

        3. in 'comment_params' method add applying of comment's parameters
         - params.require(:comment).permit(:body, :author)

        4. add 'merge' method in @comment instance to comment_params argument
         - @comment = Commen.create(comment_prams.merge(restaurant_id: params[restaurant_id]))

    - app/views/comments/create.json.jbuilder
        1. add json partial with linking to 'comment' partial
        - json.partial! @comment, partial: 'comment', as: comment

    - checking: browser
        1. add comment and check that 'POST' request has 200 status
        2. refresh the page to ensure that recently added comment still in place


-------------------------------------------------------------------------------------------------------------------
                                          Data Setting
-------------------------------------------------------------------------------------------------------------------
    1. Backing of comments rendering
        - if you remember we were already dealing with comments rendering throw 'comments' template
        - let's again back to this opening restaurant's 'show' view and adding the 'render' method
        - to do this we're going to add second argument for 'react_render' method
        - this argument gonna be 'comments' that equal to 'raw' method with 'render' argument that is method
        - 'render' has 'template' that equal to link of comment's 'index' file location
        - now let's look to source of one restaurant page
        - there pay attention to 'div' with 'data-react-props' attribute
        - this attribute should be equal to object with unreadable stuff
        - this stuff is our rendering next step is make this readable parsing JSON format

    2. Json parsing
        - go to 'CommentSection' component's constructor function
        - locate 'props' parameter to constructor's function
        - to see on these data that we take as parameter add console.log with this parameter to function's body
        - go to browser to ensure that parameter is Object with 'comments' array within another object inside
        - this another object is comment's data: id, author, body and rank
        - if data is empty can be that you havn't added comments from console or admin panel before
        - to see the parsing of JSON object add 'JSON.parse' method with 'props.comments' parameter as argument
        - as you see 'props.comments' is key of data that come as parameter
        - now look and compare result before and after parsing in console, you should see different

    3. Showing with setComments function
        - inside of  'CommentSection' component's constructor add 'this.actions.setComments' method
        - method should takes as argument JSON parsing of parameter's 'comments' key
        - that this will come to work let's add this 'setComments' function
        - for this fristly let's locate to 'constants' file
        - when look to Constants object with different keys
        - we want add one more key named as "SET_COMMENTS" with 'comments.set_comments' value
        - in the second way go to 'actions' file and new global function to 'Actions' class
        - there add 'static''setComments' function with 'params' parameter
        - as body this function should take 'AppDispatcher' with 'dispatcher' method with object inside
        - object inside should has 'actionType' key with 'Constants' object's 'SET_COMMENTS' key
        - and second key named 'comments' that equal to 'params' parameter
        - finally go to store and locate to its component's constructor where you will deal with its dispatcher
        - in dispatcher add new case that is 'Constants' object's 'SET_COMMENTS' key
        - case should has 'this''setComments' method should takes 'payload.comments' as argument
        - and has 'this''emitChagne' method
        - under constructor function we want define 'setComments' function that takes 'comments' as parameter
        - body of function should has iteration of 'commetns' parameter
        - for iteration use 'forEcah' method applying its to 'comments' parameter
        - inside this method add function that take 'comment' as parameter
        - body of function should has 'this''addComment' method with 'comment' parameter as argument
        - at last try it in browser and you should see rendering of each comment's data

-------------------------------------------------------------------------------------------------------------------
                                                  Actions form Context
-------------------------------------------------------------------------------------------------------------------
    1. Actions requirement for CommentSection
        - go to comment section, find global 'childContextTypes' function
        - add to return 'actions' key that equal to 'React.Types.func.isRequired'
    2. Getting of child context in CommentSection
        - in comment section find 'getChildContext' function
        - then add 'actions' key that equal to 'this' 'actions'
    3. Actions setting in CommentSection's constructor
        - go to constructor in comment section
        - add 'this' 'actions' that equal to Action object
        - then delete window for Actions
    4. Using of actions context in CommentForm
        - go to CommentForm and find 'submitComment' function
        - find there 'addComment' function of 'Actions' object
        - replace Actions to 'this' 'context' 'actions'
    5. Context settings for using in CommentForm
        - to make 'this' 'context' 'actions' available we must define global function that allow to use context
        - for this add 'static' 'get' 'contextTypes' function
        - body of function should return 'actions' key that has 'React.PropTypes.func.isRequired' value
    6. In browser
        - try to type text into fields and sumbit them
        - comments must successfully render to page
-------------------------------------------------------------------------------------------------------------------
                                               Comment Form
-------------------------------------------------------------------------------------------------------------------
                                                            app/assets/javascripts/components/comment_form.es6
       1. file creating
           - before start typing code we need create file file where we will locate our component
           - create this file in 'components' folder and give its 'comment_form' name with 'es6' format

       2. class definition
           - add 'CommentForm' class
           - with constructor and render functions

       3. form rendering
           - in render function return 'form' tag
           - 'form' tag should has two inputs with names 'author' and 'body'
           - also bot inputs have 'text' type

       4. showing in 'CommentSection'
           - add export of this file
           - add rendering of 'CommentForm' to 'CommentSection' class, just above 'CommentList'
           - don't forget add export and import of 'CommentForm' component

       5. state for values
           - back to form's inputs and add values for them
           - values should be expressions 'this' 'state' of 'author' or 'body' fields
           - in constructor default state for 'author' and 'body' values
           - for this add 'this' 'state' that equal to 'this' 'defaultState'
           - above define 'this' 'defaultState' that equal to object with two keys
           - first key is 'author' and second is 'body'
           - both keys should be equal to empty string

       6. events adding
           - back to browser and try to type something into field
           - for now this impossible because we don't have 'onChange' event that allow take any values
           - to fix this back to inputs and add 'onChange' event
           - event should be equal to expression of 'this' 'onFieldChange' function
           - now we want define this function adding its above 'render' function
           - 'onFieldChange' should takes 'event' parameter
           - content should contains by 'prop' variable that equal to empty object;
           - bellow 'prop' takes 'event.target.name' key that equal to 'event.target.value' value
           - as you see 'name' of 'event.target' is field's name 'author' or 'body'
           - next you want add 'setState' for current property
           - after text typing 'name' gonna equal to property of 'value' instance
           - for this add 'this' 'setState' method that takes 'prop' object as argument
           - finally we need bind 'onFieldChange' function
           - to solve problem add 'bind' method to function from 'input' tag
           - 'bind' method should take 'this' as argument

       7. form submitting
           - after fields should come 'submit' button that allow send 'form'
           - this button should has 'submit' type
           - to add ability of request sending add 'onClick' event
           - this event should be equal to expression of 'this' 'submitComment' function
           - as fields function 'submitComment' also should has 'bind' method with 'this' argument
           - next we want define this function that also should has 'event' parameter
           - when we try to click on this button we will see that page is going to refresh
           - to avoid the page refreshing we have 'preventDefault' method
           - to apply this method add its to 'event' parameter in function's body
           - next back to constructor's 'defaultState' object and add new 'id' key that equal to '1' number
           - again back to body of 'submitComment' function and add 'addComment' method of 'Actions' object
           - as argument this should takes 'this' 'state'
           - add console.log of 'this.state' to check actual object

       8. different comments
           - go to store file and find 'addComment' function
           - add aditional condition for creating a comment as key of '_comment' array
           - this will be looking like this: 'this._comments[comment.id || this._comments.length] = comment
           - 'this._comments.length' allows add id that will be next after last id
           - go to browser and try add one more comment throw form
           - you should get warring that says that your keys must be unique
           - to avoid this go to fole of 'CommentList' component nad check the returning from 'render' funciton
           - pay attention that function inside 'map' method take only one 'comment' parameter
           - let's add second that will be 'i'
           - also instead of using 'comment.id' as key of 'Comment' component we gonna use our 'i' parameter
           - now we can add comments without any warring and errors

       9. inputs cleaning
           - after then we entered comment we want taht our fields become clear again
           - for this we gonna set 'defaultState' that contains keys with empty values
           - so let's use 'this' 'setState' method with 'this' 'defaultState' argument in 'submitComment' function
           - this setting should be just after actions that add a comment

-------------------------------------------------------------------------------------------------------------------
                                                Context
-------------------------------------------------------------------------------------------------------------------
 a. Creating of CommentSection class
    - app/views/restaurants/show.html.haml
       0. in react_component use "CommentSection" instead "CommentList" from console
       *. u should have: "CommentSection is not defined" error
    - app/assets/javascripts/components/comment_section.es6
       1. create comment_section.es6 file im components folder
       2. add 'CommentSection' class that extends from React.Component
       3. add export for this this class
    - app/assets/javascripts/application.js
       1.  instead of importing to app.js use  comment_section.es6
       2.  delete app.js from required files
    - app/assets/javascripts/app.js
       0.  delete this file
    - app/assets/javascripts/components/comment_section.es6
       1. add 'window' with 'CommentSection' object that equal to new 'CommentSection'
       *. u have warring about no 'render' function from console
       2. add 'render' function to 'CommentSection' class
       3. return some text in div from 'render' function

  b. Ability to use the actions
    - app/assets/javascripts/components/comment_section.es6
       1. add 'window' with 'Actions' that equal to 'Actions'
       2. import 'Actions' from actions
    - app/assets/javascripts/actions.es6
       0. in 'Actions' class make 'addComment' as static
       *. Actions.addComment() should works from console, as output "undefined"
    - app/assets/javascripts/components/comment_section.es6
       1. define a 'constructor' with 'super' function
       2. add 'this' 'store' that equal to 'new' 'CommentStore' class
       3. add import of 'CommentStore' from comment_store file in stores folder
       *. try to use 'addComment' function throw console and you'll get error
          that says: "commentStore is not defined"
       4. go to store file and change 'addComment' in dispatcher to 'this'
       *. try to use 'addComment' fuc. again and this should works
       *. go to store's 'addComment' func. and add consloe log for 'this' '_comments' array
          then try to use func. throw console and you will see array with added info
       5. instead of returning previois stuff in 'render' func.
          return CommentList component with 'store' property that equal to expression of 'this' 'store' from constructor
          in CommentList change 'commentStore' to 'this' 'store'
    - app/assets/javascripts/components/comment_list.es6
       1. change format from 'js.jsx' to 'es6'
       2. change syntax structure of class to es6 format
       3. change 'commentStore' to 'this' 'props' 'store' taking property from 'CommentSection' class
       4. add export of 'CommentList' component
       *. try to use 'addComment' function and u will get error like: "this.forceUpdate is not a function(â€¦)"
       5. change argument of 'addChangeListeners' and 'removeChangeListeners' in 'componentDidMount' and
          'componentWillUnmount' passing 'bind' as method to '_onChange' function in both cases
          'bind' method should takes 'this' argument
       *. try replay using of 'addComment' function now it should works

  c. Rendering of component
     - app/assets/javascripts/components/comment.es6
       1. change format from 'js.jsx' to 'es6'
       2. change syntax of 'Comment' component to es6
       3. add export of 'Comment' component
       4. add import of 'Comment' to 'CommentList' component

  d. Context using
     - app/assets/javascripts/components/comment_component.es6
       1. add 'static..' 'get' of 'childContextTypes' function in 'CommentSection' component
          return there 'store' that equale to 'React.PropTypes.object.isRequired'
       2. add new 'getChildContext' function in 'CommentSection' component
          return 'store' that equale to 'this' 'store'
       * refresh page to ensure that u don't have errors in console
       3. delete 'store' property from rendering of 'CommentList' component
       * refresh page now and u'll get error that says "Cannot read property 'removeChangeListener' of undefined"
     - app/assets/javascripts/components/comment_component.es6
       1. change 'props' of 'store' in 'componentDidMout', 'componentWillUnmount' functions
          and in returning of 'render' function to 'context'
       2. add 'static' 'get' of 'contextTypes' function that
          return 'store' that equale to 'React.Prop.Types.object.usRequired'
       * use console to add comment to page, rendering should works as before 'context' adding

-------------------------------------------------------------------------------------------------------------------

                                                 Modules

-------------------------------------------------------------------------------------------------------------------
 a. Adding files to vendor
       1. https://github.com/systemjs/systemjs/tree/master/dist system.js.map system.js
       2. https://github.com/ModuleLoader/es6-module-loader/ es6-module-loader.js.map es6-module-loader.js
       3. create app/vendor/javascripts/es6 and locate this there these files (4 files)
       4. in app/assets/javascripts/application.js file
          include as required es6/es6-module-loader and es6/system
          requirements should have order, first: es6/es6-module-loader, second es6/system and only then other stuff
          check scripts comming in browser

 b. Restructuring by modules Part I
   - app/assets/javascripts/constants.es6
       1. create this file
       2. locate there "Constants" object from app.js deleting this from app.js (Ctrl + X, Ctrl + V)
          console: commentActions.addComment({ id: 1, body: "works"}), rendering: component with properties
       3. add export as default to "Constants"
          console:
            - you should get following error: "Uncaught ReferenceError: exports is not defined"
            - and another error: "Uncaught TypeError: Cannot read property 'CHANGE_EVENT' of undefined"
   - config/application.rb
          add configuration for register transformer:
     # Rails.application.config.assets.configure do |env|
     #      env.register_transformer 'text/ecmascript-6', 'application/javascript',
     #                               Sprockets::ES6.new('modules' => 'system', 'moduleIds' => true)
     #    end
   - change version of sprockets-6 gem to "gem 'sprockets-es6', '0.6.1'"
   - $ bundle update
   - $ rails s
   - localhost:3000/restaurants/:id open console, output should says about "commentStore is not defined" error

 c. Restructuring by modules Part II
   - app/assets/javascripts/components/comment_list
       change "commentStore" word to "Store" everywhere that is is
   - app/assets/javascripts/stores/comment_store.es6
       1. create "stores" folder wit "comment_store.es6" file
       2. copy and paste "Store" class from app.js file
       3. rename "Store" to "CommentStore" and add export of this class
   - app/assets/javascripts/app_dispatcher.es6
       1. "app_dispathcer.es6" file
       2. cut and paste "AppDispatcher" variable and export its
   - app/assets/javascripts/actions.es6
       1. create "actions.es6" file
       2. locate there "Actions" class from app.js file
       4. add export for this class
   - app/assets/javascripts/stores/comment_store.es6
       1. locate to "CommentStore" class's "constructor" "AppDispatcher" with "register" method
       2. in switch of dispatcher rename "commentStore" to "this"
   - app/assets/javascripts/application.js
       add "System" "import" for "app" file
   - app/assets/javascripts/app.js
       a. for checking
            1. replace all content in file if you still have
               to alert with some text
               go to browser, you should get your alert
            2. clear up alert and ensure that file is empty
       b. returining to previous functional
            1. add "window" with "commentStore" object and make it equal to "CommentStore" object
            2. add importing of "CommentStore" from its location, /stores/comment_store
               console: commentStore, output: Object with stuff
            3. add "window" for "commentActions" object and make it equal to "Actions" object
            4. add importing of "Actions" from its location, /actions
               console: commentActions.addComments({id: 1}), rendering of component with properties

-------------------------------------------------------------------------------------------------------------------
                                           Converting to ES6 syntax
-------------------------------------------------------------------------------------------------------------------
 a. Stuff cleaning
   - app/assets/javascripts/hello.es6
       delete this file

 b. Restructuring to ES6
   - app/assets/javscripts/app.es6
       1. rename this file from "js" format to "es6"
       2. check that functional still works, for this:
          console: Actions.addComment({id: 1, body: "works"}), rendering compoennt's stuff to page
       3. instead 'var' use const to store "Constants" object
       4. instead of store to new extend with 'var' keyword use
          'class' + "Store" as class's name that "extends" from "EventEmitter"
           and contain all too class's body "{ ... }"
       5.  define 'constructor' function
           contain in body of this function empty "_comments" comment array adding "this" keyword
           add "super" function to add "constructor" function inheritance
       4. clean up all commas after every function in class's body
       5. change structure of every function in body of class following example above:
          func_name (par) { ... }
          check that page rendering without mistakes
          look to console, you should have "Store.comments is not a function" error
       6. add "commentStore" variable that equal to new "Store" object
       8. in body of dispatcher's switch rename "Store" to "commentStore"
   - app/assets/javascripts/cpmponents/comment_list.js.jsx
       1.  in JSX rendering rewrite "Store" to "commentStore"
       2. do the same for "Store" in functions bodies under "render" function
          check result in browser, adding of objects to Store throw console still should works
   - app/assets/javscripts/app.es6
       1. change "var" of AppDispatcher to "let"
       2. change structure of function that is first argument of dispatcher's register to es6 format
          for this delete "function" keyword and add "=>" after parameter
          instead taking "action" variable as parameter of switch type just: "payload.actionType"
       3. change "Actions" variable with ew extend to "class" with "Actions" name
          then contain in body "{ ... }" all stuff from second argument of extend method that was before
          deal with syntax of "addComment" function
       4. Add new variable that equal to new "Actions" object that "addComment" function will be used
          console: commentActions.addComment({ id: 1, author: "Bob", body: "I love this shit", rank: 7})
          rendering: object with structure of "CommentList" component

-------------------------------------------------------------------------------------------------------------------
                                            EcmaScript 6 Implementation
-------------------------------------------------------------------------------------------------------------------
 a. Gem for reading ES6
   - Gemfile: gem 'sprockets-es6'
   - $ gem install sprockets-es6
   - $ rails s

 b. Work ability
   - app/assets/javascripts/hello.es6
       1. create file
       2. ad variable with some string, instead of "var" use "let"
       3. localhost:3000, Ctrl+ U, find "hello..." script and opent its
       4. ensure that file transorm es6 to js, instead of "let" you should see "var" there
       5. back to file and add function that takes as parameter declared variable
          alert this parameter and call the function
       6. back to browser and refresh page, you should see alert with your message

-------------------------------------------------------------------------------------------------------------------
                                  Flusx Implementation (Actions, Sotre)
-------------------------------------------------------------------------------------------------------------------
 a. Flux installing
   - Gemfile: gem 'flux-rails-assets'
   - $ gem install flux-rails-assets
   -- app/assets/javascripts/application.js
        1. Include: //= require flux
                    //= require eventemitter
        2. Make order: "react", "react_ujs", "flux", "eventemitter" only before "components"
        3. Add: "//= require app" after "components"
   - localhost:3000
        1. Ctrl + U
        2. check that u have script with src="assets/flux..."

 b. Events naming
   - app/assets/javascripts/application.js:
        Add: "//= require app" after "components"
   - app/assets/javascripts/app.js:
        1. Create app.js file
        2. add variable equal to object
        3. add keys pare that equal to events, keys should be uppercase
        4. first key should be event changer that has "change" value
        5. second key equal to data adding to comments array, "comments.add"

 c. Lodash installing
   - Gemfile: gem 'lodash-rails'
   - $ gem install lodash-rails
   - app/assets/javascripts/application.js:
        "//= require lodash" before "components"
   - localhost:3000
        1. open console
        2. enter "_"
        3. ensure that you get "function" after symbol sending

 d. Adding comments to Store throw addComment function to  _comments array
   - app/assets/javascripts/app.js
        1. define store variable equal to new extend
            extend should take as argument empty object, EventEmitter.prototype and another object
           - console: Store, output: Object {_events: undefined, maxListeners: undefined}
         2. in third object add "_comments" key with array that contain "1" number as value, "_comments: [1]"
            - console: Store, output: Object { ... undefined, _comments: Array[1]}
            - console: Store._comments, output: [1]
            - console: EventEmitter.prototype, output: {_events: undefined, _maxListeners: undefined}
            - console: EventEmitter.prototype._comments, output: undefined
            make _comments equal to empty array instead containing of "1" number, "_comments: [1]"
         3. add function named "addComment" that takes "comment" parameter
            inside "addComment" function add "comment" object that is parameter
            "comment" object should has  "id" key, this data should be in "this" "_comments" array
            make this data within array equal to taken "comment" parameter
            - console: Store.addComment({id: 1, body: "Hi!"})
            - console: Store._comments, output: object with recently added content
         4. add "comments' function that return this "_comments" array

  e. Flux Implementation Part I
    - app/assets/javascripts/app.js
        1. add "addChangeListeners" function that takes "callback" as parameter
           within this function add "this" "on" method
           "on" method should takes "Constants" object "CHANGE_EVENT" key and "callback" par. as second argument
        2. add "removeChangeListeners" function with "callback" parameter
           within this function add "this" "removeListeners" method
          "removeListeners" method should takes "Constants" object 's "CHANGE_EVENT" key and "callback" par. as second arg.
        3. add "emitChange" function that contain "this" "emit"
           method takes as argument "Constants" object with "CHANGE_EVENT" key

  f. Flux Implementation Part 2
    - app/assets/javascripts/app.js
        1. add "AppDispatcher" variable that equal to new "Flux"'s "Dispatcher" method
        2. on ntext string add "register" method to "AppDispatcher"
        3. method should take function with "payload" parameter
        4. inside function add "action" variable that equal to "payload" parameter's "actionType"
        6. under variable define switch that takes "action" variable as parameter
        7. switch should has "Constants" class's "ADD_COMMENT" key
        8. this case should describe "Store" with "addComment" method that takes "payload" parameter's "comment"

  g. Data comming
    - app/views/restaurants/show.html.haml
        remove data rendering that is second argument of react_component method
    - app/assets/javascripts/components/comment_list.js.jsx
        remove "comments" array and instead add empty array

  h. Component lifecycle
    - app/assets/javascripts/components/list_component.js.jsx
        1. add "componentDidMount" function that contains
           "Store" with "addChangeListener" method that takes
           "this" "_onChange" function as argument
        2. declare "_onChange" function that contains
           "this" "forceUpdate" method as argument
        3. add "componentWillMount" function that contains
            "Store" with "removeChangeListener" method that takes
            "this" "_onChange" function
        4. add some text to "console.log" to check that constructor is work

  i. Actions adding
    - app/assets/javascripts/app.js
        1. add Actions variable that equal to new "extend" method that takes two arguments
        2. first argument is an empty object
        3. second is "addComment" function that takes "params" as parameter
        4. function contains "AppDispatcher" that has "dispatch" method
        5. method takes as argument object with "actionType" and "comment" keys
        6. first "actionTypes" key is equal to "Constants" object's "ADD_COMMENT" key that is "'comments.add'"
        7. second "comment" key is equal to gotten "params" parameter
            - console: Actions, output: object with "addComment" function
            - add console.log(payload) before "AppDispatcher"'s switch
            - console: Actions.addComment({id: 1, body: "it works"}),
                       output: Object with "actionType" that equal to "comments.add" action
                       and "comment" that equal to other Object that store recently added data: id: 1, body: "it works"
            - mark console.log(payload) as comment and refresh page
            - console: Store.comments(), output: empty array
            - console: Actions.addComment({id: 1, body: "works"})
            - console: Actions.addComment({id: 2, body: "also works"})
            - console: Store.comments(), output: recently added objects throw "Actions"'s "addComment" function
        8. in "AppDispatcher" that takes register method add to case "Store" with "emitChange" method
            - add console.log("rendering") into CommentList to rendering
            - refresh page and type in to console: Actions.addComment({id: 1, body: 'hi"})
            - output should be a "rendering" text after every time when we add objects to store
        9. Go to CommentList component instead of empty array add "Store.comments()" function to map elements
            - console: Actions.addComment({id: 1, author: "Alex", body: "hey, it works", rank: 9})
            - rendering: jsx following CommentList's structure
            - make as comment "console.log("rendering") in render function

-------------------------------------------------------------------------------------------------------------------
                                             Comments throw Json
-------------------------------------------------------------------------------------------------------------------
 a. Template adding
    - app/views/restaurants/show.html.haml:
        1. delete iteration
        2. insted of "Comment" component add new "CommentList"
        3. add raw with rendering of 'comments/index.json.jbuilder' template insteat of properties declaring
    - app/views/comments/index.json.jbuilder
        1. create comments folder with index.json.jbuilder file
        2. add json array of comments
        3. add 'comments/comment' partial as comment
    - app/views/comments/_comment.json.jbuilder
        1. create this comment.json.jbuilder partial in comments folder
        2. add comment with id, author, body and rank parameters
        3. convert comment with parameters to json format
    - localhost:3000/restaurants/:id
        1. come to page of one restaurant
        2. come Ctrl + U
        3. check that source of page has react properties
           Example: <div data-react-class="CommentList" data-react-props="{&quot;comments&quot;:&quot; ... </div>

b. Comment recreating
    - app/assets/javascripts/components/comment_list.js.jsx
        1. create comment_list.js.jsx file in components folder
        2. Define CommentList class inherited from React class
        3. Render JSX
        4. In JSX iterate throw "comments" array with map method
        5. Contain function with "comment" parameter as argument of map method
        6. Return "Comment" component
        7. Contain "author", "body" and "rank" properties to "Comment" component
        8. Make recently declared properties equal to key of "comment" object, example: "body={comment.body}"
        9. Add "key" property to "Comment" component and make it equal to "comment" object's "id" key
        10. Make code clearly. Use shortcut expressions declaring. Example: "{ ... comment }"
        11. Check work in localhost:3000/restaurants/:id in Comment's section



-------------------------------------------------------------------------------------------------------------------
                                       Showing throw comments iteration
-------------------------------------------------------------------------------------------------------------------
   Showign throw iterating
    - app/controllers/restaurant_controller:
        define new @comments instance in show action with all restaurant's comments data
    - app/views/restaurants/show.html.erb:
        iterate throw @comments instance to show all properties of current comment in "Comment" component

-------------------------------------------------------------------------------------------------------------------
                                           First Component
-------------------------------------------------------------------------------------------------------------------
 a. React gem
    - Gemfile: gem 'react-rails'
    - $ gem install react-rails
    - $ rails g react:install
    - app/assets/javascripts/application.js:
        //= require react
        //= require react_ujs
        //= require components
    - localhost:3000
    - Ctrl + U, ensure that you have scripts like this: src='assets/react...'

 c. Component creating
    - app/views/restaurants/show.html.haml:
        1. add comment section
        2. add react_component with 'Comment' name
        3. add properties to this component (author, body, rank)
        4. add comment form for structure organization
    - app/assets/javascripts/components/comment.js.jsx:
        1. create comment.js.jsx
        2. create there Comment class inherited from React class
        3. render jsx with exporession describes comment's properties
    - localhost:3000/restaurants/:id to check that properties comes to page


-------------------------------------------------------------------------------------------------------------------
                                           Pages Structure
-------------------------------------------------------------------------------------------------------------------
 a. All restaurants on home page
    - app/controllers/restaurants_controller.rb:
        @restaurants instance to index action with all restaurants
    - app/views/restaurants/index.html.haml
        @restaurants iterating for info. showing
        linking to show page of every restaurant
 b. One restaurant page
     - app/controllers/restaurants_controller.rb:
        add a "show" action with @restaurant instance one restaurant info showing
     - app/views/restaurants/show.html.haml
        create show.html.haml file
        show there info about restaurant
        add the back link and links for info manipulation

 d. New restaurant page
     - app/controllers/restaurants_controller.rb:
       add "new" and "create" actions to make data creating available throw user interface
     - app/views/restaurants/new.html.haml
        create new.html.haml file with partial rendering

 e. Form partial
     - Gemfile: gem 'simple-form'
     - gem install simple-form
     - rails generate simple_form:install --bootstrap
     - app/views/restaurants/_form.html.haml
        create _form.html.haml partial with acording form to manipulate by parametres
     - models/restaurant.rb
        add validation

 f. Restaurant edit page
    - app/controllers/restaurants_controller
       add 'edit' action to restaurants controller with acording functional
    - app/views/restaurants/edit.html.erb
       render form partial

 g. Destroy action
    - app/controllers/restaurants_controller
        add 'destroy' action to restaurants controller with acording functional
    - app/views/restaurants/show.html.erb
        come to page of certain restaurant and check work ability of delete function



-------------------------------------------------------------------------------------------------------------------
                                            Home Page Defining
-------------------------------------------------------------------------------------------------------------------
 a. Controller generation
     - $ rails g controller restaurants index

 b. Routes configuration
    - confing/routes.rb:
        resources :restaurants
        root 'restaurants#index'

 c. Haml Applying
    - Gemfile: gem 'haml'

 d. Views containing
    - rename index.html.erb in restaurants folder to index.html.haml
    - app/views/restaurants/index.html.haml:
        %h1 Hello World
    - localhost:3000

 e. Botstrap setting
    - Gemfile:
        gem 'bootstrap-sass'
    - gem install bootstrap-sass
    - rename "appliaction.css" to "application.css.scss"
    - app/assets/stylesheets/application.css.scss:
        @import "bootstrap-sprockets";
        @import "bootstrap";
    - app/assets/javascripts/application.js
        //= require bootstrap-sprockets

 f. Rename application.html.erb layout to application.html.haml
    - change everything to haml style
    - bootstrap's styles for HTML skeleton
    - add link to root_path and link to rails_admin_path

---------------------------------------------------------------------------------------------------------------------
                                        Setting Up The Model Layer
---------------------------------------------------------------------------------------------------------------------
 a. Ancestry gem adding
    - gem 'ancestry'
    - $ gem install ancestry

 b. New model creating
    - $ rails g model Comment author:string body:text rank:integer restaurant:belongs_to
    - $ rake db:migrate
    - models/comment.rb:
      'belongs_to :restaurant' (should be default)
    - models/restaurant.rb:
      'has_many :comments'

 c. Validation
    - models/comment.rb: 'validates :restaurant, presence: true'
    - $ rails server
    - check in browser 'localhost:3000/admin/comment/new' - 'required' text under 'Restaurant' select field

 d. Record creating
    - $ rails console
    - $ Comment.connection
    - $ Comment.create(author: "Alex", body: "I love this shit", rank: 9, restaurant_id: 1)

 e. Admin panel overview
    - $ rails s
    - in browser: localhost:3000/admin/comment

 f. Ancestry column for relationships
    - $ rails g migration add_ancestry_to_comment
    - migrate/20160527082254_add_ancestry_to_comment:
        'add_column :comments, :ancestry, :string',
        'add_index :comments, :string'
    - $ rake db:migrate
    - models/comment.rb:
        'has_ancestry'
    - $ rails s
    - 'localhost:3000/amdin/comment/new' check ancestry option

 g. Ancestry comment  adding
    - $ rails c
    - > Comment.create(author: "Bob", body: "Alex, I love this sit too", parent: Comment.find(1), restaurant_id: 1)
    - in browser 'localhost:3000/admin/comment/:id/edit' look at Ancestry option, it should has a number
    - > Comment.find(1).children
    - > Comment.find(2).path

-------------------------------------------------------------------------------------------------------------------
                                Scaffolding the Application with Admin Panel
-------------------------------------------------------------------------------------------------------------------
 a. Application creating
    - $ rails new reilly_restaurants
    - $ cd reilly_restaurants

 b. Admin gem uploading
    - gem 'rails_admin'
    - $ bundle install
    - $ rails g rails_admin:install

 c. Model creating
    - $ rails g model Restaurant name:string address:string description:text
    - $ rake db:migrate

 d. Adding records to data base
    - $ rails console
    - > Restaurant.connection
    - > Restaurant.create(name: "Bungalo", address: "Grow Street, 5", description: "You must try this!")

 e. Admin panel overview
    - $ rails server
    - in browser: localhost:3000/admin/restaurant

-------------------------------------------------------------------------------------------------------------------